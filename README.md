# secfi-assignment

## Description
The idea is to create a microservice that allows CRUD operations on a “users” table. The assignment doesn’t have a
hard time limit but we also don’t want to take too much of your time, so try to spend a maximum of 4/5 hours on it.
The service should allow read and write operations following this interface:
```json
interface IUser {
    firstName: string;
    lastName: string;
    userName: string;
    password: string;
    avatar: string;
}
```
- Service should be written in Python or TypeScript
- Service should run in a Docker container
- Password should be stored in encrypted format
- For the avatar, pick a way of storing you think is most efficient
- Database can be any type (Postgresql, MySQL, SQLite)

## How to run demo server with Docker
1. Run `docker-compose up --build` This will spin up a Django development server in http://localhost:8000
2. Make GraphQL requests to `http://localhost:8000`. See examples in the [Postman collection](postman)

## How to develop
1. Install [poetry](https://python-poetry.org/)
2. `poetry install`
3. `poetry run manage.py runserver`
4. Go to `http://localhost:8000` since GraphiQL explorer is enabled

## How much time did you end up spending on it?

## What are some of the design decisions you made?

## What do you like about your implementation?

## What would you improve next time?
This is a very basic implementation of a microservice and there is a lot of room for improvement with it.

Given more time I would:
1. First of all clarify requirements regarding the expected input and output of the API and if the API should be GraphQL or REST
2. Add filtering and pagination to the `allUsers` query (it is the query that returns all of the users in table)
3. Add support for partial updates (i.e. the ability to update a subset of attributes of the user in the mutation)
3. Improve API error messaging
4. Perform stronger validation against passwords. For example, check if the password is entirely numeric or is in a list of common passwords
5. Add random salt to password hashing
6. Use an external Postgres or MySQL database and not sqlite3
7. [Add unit tests](https://docs.graphene-python.org/projects/django/en/latest/testing/)
8. Dockerize the Django application with a production ready WSGI server such as [gunicorn](https://gunicorn.org/)
9. Improve logging. For example, the logs do not provide information about which `Query` or `Mutation` handler is called or what kind of error happened to handler
10. Deploy dockerized application to a demo server in order to make it easier for the reader to test the API

I might be extending the scope here bu given more information about how the user microservice will be internally integrated with the rest of the microservices in the system I would maybe:
1. Set up health check endpoint that will be used for load balancers
2. Set up the infrastructure for the user microservice
3. Maybe include authentication / authorization that will check the validity of JWT tokens generated by the "authentication" microservice
4. Set up rate limiting. Rate limiting in this case would be using a custom HTTP header that corresponds to each microservice that uses the user microservice